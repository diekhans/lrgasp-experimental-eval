#!/usr/bin/env python3

import sys
from os import path as osp
import re
from collections import namedtuple
import argparse
import pysam
from pycbio.sys import fileOps

def parseArgs():
    desc = """get stats on alignment to transcriptome"""
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--target",
                        help="""only analyze this target name""")
    parser.add_argument("--maxEndsDiff", type=int, default=None,
                        help="""maximum variation in ends""")
    parser.add_argument("--maxIndelBases", type=int, default=None,
                        help="""maximum indel bases""")
    parser.add_argument("--maxIndelBaseRate", type=float, default=None,
                        help="""maximum indel bases rate""")
    parser.add_argument("--readStatsTsv",
                        help="""output per-read statistics to this file""")
    parser.add_argument("--filteredBam",
                        help="""output BAMs passing the filter""")
    parser.add_argument("transBam",
                        help="""alignment to transcriptome BAM""")
    parser.add_argument("statsTsv",
                        help="""output statistics to this file""")
    return parser.parse_args()

class AlignStats(namedtuple("AlignStats",
                            ("qName",
                             "qSize",
                             "strand",
                             "qStartOff",
                             "qEndOff",
                             "alnBases",
                             "qDels",
                             "qDelBases",
                             "tDels",
                             "tDelBases",
                             "indelBaseRate"))):
    pass

def fmtCigar(cigar):
    return re.sub("([A-Z])", "\\1 ", cigar).strip()

def debugDump(aln, rstats, fh=sys.stderr):
    for fld in ("target_name", "target_length", "target_start", "target_end"):
        fileOps.prRowv(fh, fld, getattr(aln, fld))
    fileOps.prRowv(fh, "cigar", fmtCigar(aln.cigarstring))

    for fld in AlignStats._fields:
        fileOps.prRowv(fh, fld, getattr(rstats, fld))
    fh.write('\n')

def computeReadStats(aln):
    # soft clipped is handled by end filters
    baseCnts, blkCnts = aln.get_cigar_stats()
    alnBases = baseCnts[pysam.CMATCH] + baseCnts[pysam.CEQUAL] + baseCnts[pysam.CDIFF]
    qDels = blkCnts[pysam.CDEL] + blkCnts[pysam.CREF_SKIP]
    qDelBases = baseCnts[pysam.CDEL] + baseCnts[pysam.CREF_SKIP]
    tDels = blkCnts[pysam.CINS]
    tDelBases = baseCnts[pysam.CINS]
    indelBaseRate = (qDelBases + tDelBases) / (alnBases + qDelBases + tDelBases)

    return AlignStats(qName=aln.query_name,
                      qSize=aln.query_length,
                      strand=('-' if aln.flag & pysam.FREVERSE else '+'),
                      qStartOff=aln.reference_start - aln.query_alignment_start,
                      qEndOff=aln.reference_end - aln.query_alignment_end,
                      alnBases=alnBases,
                      qDels=qDels,
                      qDelBases=qDelBases,
                      tDels=tDels,
                      tDelBases=tDelBases,
                      indelBaseRate=round(indelBaseRate, 4))

def filterReadStats(rstats, maxEndsDiff, maxIndelBases, maxIndelBaseRate):
    if rstats.strand == '-':
        return False
    if (maxEndsDiff is not None) and ((abs(rstats.qStartOff) > maxEndsDiff) or (abs(rstats.qEndOff) > maxEndsDiff)):
        return False
    if (maxIndelBases is not None) and ((rstats.qDelBases + rstats.tDelBases) > maxIndelBases):
        return False
    if (maxIndelBaseRate is not None) and ((rstats.indelBaseRate) > maxIndelBaseRate):
        return False
    return True

def collectReadsStats(bamFh, target, filteredBamFh, maxEndsDiff, maxIndelBases, maxIndelBaseRate):
    # recs are AlignedSegment
    readsStats = []
    for aln in bamFh.fetch(reference=target):
        rstats = computeReadStats(aln)
        if filterReadStats(rstats, maxEndsDiff, maxIndelBases, maxIndelBaseRate):
            readsStats.append(rstats)
            if filteredBamFh is not None:
                filteredBamFh.write(aln)
    return readsStats

def readStatsOpen(readStatsTsv):
    readStatsFh = open(readStatsTsv, "w")
    fileOps.prRowv(readStatsFh, "target", *AlignStats._fields)
    return readStatsFh

def readStatsWrite(target, readsStats, readStatsFh):
    for rstats in readsStats:
        fileOps.prRowv(readStatsFh, target, *rstats)

def writeTargetHeader(statsFh):
    fileOps.prRowv(statsFh, "target", "numSupports", "minEndsDiff", "minIndelBases", "minIndelBaseRate", "filter_maxEndsDiff", "filter_maxIndelBases", "filter_maxIndelBaseRate")

def maxOffset(rs):
    "maximum offset from 0, maintaining strand"
    if abs(rs.qStartOff) >= abs(rs.qEndOff):
        return rs.qStartOff
    else:
        return rs.qEndOff

def minOrNone(vals):
    if len(vals) == 0:
        return None
    minVal = sys.maxsize
    for val in vals:
        if abs(val) < minVal:
            minVal = val
    return minVal

def calcMinStats(readsStats):
    # minimum ends offset is annoying due to negatives, here the min is the max of the
    # of the individual mins ignoring the sign

    minEndsDiff = minOrNone([maxOffset(rs) for rs in readsStats])
    minIndelBases = minOrNone([rs.qDelBases + rs.tDelBases for rs in readsStats])
    minIndelBaseRate = minOrNone([rs.indelBaseRate for rs in readsStats])

    return (minEndsDiff, minIndelBases, minIndelBaseRate)

def writeTargetStats(target, readsStats, maxEndsDiff, maxIndelBases, maxIndelBaseRate, statsFh):
    minEndsDiff, minIndelBases, minIndelBaseRate = calcMinStats(readsStats)
    fileOps.prRowv(statsFh, target, len(readsStats),
                   minEndsDiff, minIndelBases, minIndelBases,
                   maxEndsDiff, maxIndelBases, maxIndelBaseRate)

def processTarget(bamFh, target, readStatsFh, statsFh, filteredBamFh,
                  maxEndsDiff, maxIndelBases, maxIndelBaseRate):
    readsStats = collectReadsStats(bamFh, target, filteredBamFh, maxEndsDiff, maxIndelBases, maxIndelBaseRate)
    if readStatsFh is not None:
        readStatsWrite(target, readsStats, readStatsFh)
    writeTargetStats(target, readsStats, maxEndsDiff, maxIndelBases, maxIndelBaseRate, statsFh)

def processTargets(bamFh, target, readStatsFh, statsFh, filteredBamFh,
                   maxEndsDiff, maxIndelBases, maxIndelBaseRate):
    targets = (target,) if target is not None else bamFh.references
    for atarget in targets:
        processTarget(bamFh, atarget, readStatsFh, statsFh, filteredBamFh, maxEndsDiff, maxIndelBases, maxIndelBaseRate)

def transcriptomeAlignAnalyze(transBam, statsTsv, target, readStatsTsv, filteredBam,
                              maxEndsDiff, maxIndelBases, maxIndelBaseRate):
    with pysam.AlignmentFile(transBam) as bamFh:
        readStatsFh = readStatsOpen(readStatsTsv) if readStatsTsv is not None else None
        filteredBamFh = pysam.AlignmentFile(filteredBam, 'wb', template=bamFh) if filteredBam is not None else None

        with open(statsTsv, 'w') as statsFh:
            writeTargetHeader(statsFh)
            processTargets(bamFh, target, readStatsFh, statsFh, filteredBamFh,
                           maxEndsDiff, maxIndelBases, maxIndelBaseRate)
        if readStatsFh is not None:
            readStatsFh.close()
        if filteredBamFh is not None:
            filteredBamFh.close()

def main(opts):
    transcriptomeAlignAnalyze(opts.transBam, opts.statsTsv, opts.target, opts.readStatsTsv, opts.filteredBam,
                              opts.maxEndsDiff, opts.maxIndelBases, opts.maxIndelBaseRate)

main(parseArgs())
